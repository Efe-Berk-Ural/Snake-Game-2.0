<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Snake 2.0 | Efe Berk Ural</title>
<style>
  :root { --fg:#0f0; --bg:#111; --panel:#111; --accent:#0f0; }
  *{box-sizing:border-box}
  body {
    margin:0; padding:0; background:#111; color:white;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display:flex; flex-direction:column; align-items:center; height:100vh;
    overflow:hidden; user-select:none;
  }
  h1 { margin:12px 8px 6px; font-size:1.4rem; color:#0f0; text-align:center; }
  #topBar { display:flex; gap:8px; align-items:center; }
  #gameContainer {
    position: relative; margin-top: 6px; background: #222;
    border: 3px solid #0f0; border-radius: 12px; touch-action: none;
  }
  canvas { display:block; background:#000; border-radius:10px; }
  #score,#highScore,#lives,#timer {
    position:absolute; font-weight:bold; font-size:1.05rem; color:#0f0; pointer-events:none;
    text-shadow:0 0 4px #000;
  }
  #score{ top:5px; right:10px; }
  #highScore{ top:5px; left:10px; }
  #lives{ bottom:6px; left:10px; }
  #timer{ bottom:6px; right:10px; }
  #controls {
    margin-top: 10px; display:grid; grid-template-columns:repeat(3,60px); grid-template-rows:repeat(2,60px); gap:10px;
  }
  button.control-btn {
    background:#222; border:2px solid #0f0; border-radius:12px; color:#0f0; font-size:1.8rem;
    cursor:pointer; outline:none; display:flex; justify-content:center; align-items:center;
    transition:background .25s; touch-action:manipulation; user-select:none;
  }
  button.control-btn:active { background:#0f0; color:#000; }
  #upBtn { grid-column:2; grid-row:1; } #leftBtn{grid-column:1;grid-row:2}
  #downBtn{grid-column:2;grid-row:2} #rightBtn{grid-column:3;grid-row:2}
  @media (max-width: 480px) {
    #controls{ grid-template-columns:repeat(3,50px); grid-template-rows:repeat(2,50px); gap:8px; }
    button.control-btn{ font-size:1.5rem; width:50px; height:50px; }
  }
  #pauseBtn{
    margin-top:8px; background:#222; border:2px solid #0f0; color:#0f0; padding:8px 20px; border-radius:12px; font-size:1rem; cursor:pointer;
  }
  #pauseBtn:active{ background:#0f0; color:#000; }
  /* Panels */
  .panel {
    position:absolute; top:10px; left:10px; background:#111; border:2px solid #0f0; border-radius:12px;
    padding:14px; z-index:1000; display:none; color:#0f0; max-width:min(92vw,420px);
  }
  .panel.visible{ display:block; }
  .panel h2,.panel h3{ margin:6px 0 10px; }
  .panel button, .panel .btn {
    background:#222; border:1px solid #0f0; color:#0f0; padding:6px 10px; border-radius:8px; margin:4px 0; cursor:pointer;
  }
  .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  fieldset{ border:1px solid #0f0; border-radius:10px; margin:8px 0; padding:8px 10px;}
  legend{ padding:0 6px; }
  label{ display:block; margin:4px 0; }
  input[type="range"]{ width:140px; vertical-align:middle; }
  select, input[type="checkbox"]{ accent-color:#00ff80; }
  /* Modal */
  #gameOverModal {
    position: fixed; inset:0; background: rgba(0,0,0,0.75);
    display:flex; justify-content:center; align-items:center;
    visibility:hidden; opacity:0; transition: opacity .3s ease; z-index: 999;
  }
  #gameOverModal.visible{ visibility:visible; opacity:1; }
  #gameOverContent {
    background:#222; border:3px solid #0f0; padding:20px 30px; border-radius:15px; text-align:center; color:#0f0;
  }
  #gameOverContent button{
    margin-top:12px; background:#0f0; color:#000; border:none; padding:10px 22px; font-size:1.1rem; border-radius:12px; cursor:pointer;
  }
  /* Level picker mini */
  .lvlRow{ display:flex; align-items:center; gap:8px; }
  .lvlName{ font-weight:bold; }
</style>
</head>
<body>
  <h1>Advanced Snake 2.0 | Efe Berk Ural</h1>

  <!-- Main Menu -->
  <div id="mainMenu" class="panel visible" aria-labelledby="menuTitle">
    <h2 id="menuTitle">Main Menu</h2>
    <div class="row">
      <button class="btn" data-action="play">Play</button>
      <button class="btn" data-action="modes">Modes</button>
      <button class="btn" data-action="levels">Levels</button>
      <button class="btn" data-action="settings">Settings</button>
      <button class="btn" data-action="achievements">Achievements</button>
      <button class="btn" data-action="howto">How to Play</button>
    </div>
    <div style="margin-top:8px; font-size:.9rem; color:#9f9;">Tip: Use Settings to enable/disable modules.</div>
  </div>

  <!-- Settings Panel -->
  <div id="settingsPanel" class="panel" aria-labelledby="settingsTitle">
    <h3 id="settingsTitle">Settings</h3>

    <fieldset>
      <legend>Gameplay</legend>
      <label><input type="checkbox" id="optLevelsWalls" checked> Levels & Walls</label>
      <label><input type="checkbox" id="optPortals"> Portals</label>
      <label><input type="checkbox" id="optPowerups" checked> Power-ups</label>
      <div id="powerupSub" style="margin-left:16px">
        <label><input type="checkbox" id="optPUShield" checked> Shield</label>
        <label><input type="checkbox" id="optPUSlow" checked> SlowMo</label>
        <label><input type="checkbox" id="optPUMagnet" checked> Magnet</label>
      </div>
      <label><input type="checkbox" id="optEnemySnake"> Enemy Snake</label>
      <label><input type="checkbox" id="optLives" checked> Lives (3)</label>
      <label><input type="checkbox" id="optTimeTrial"> Time Trial (60s)</label>
      <label><input type="checkbox" id="optSurvival"> Survival (ramps up)</label>
      <label><input type="checkbox" id="optQuests"> Quests</label>
    </fieldset>

    <fieldset>
      <legend>Controls & UX</legend>
      <label><input type="checkbox" id="optInputBuffer" checked> Input Buffer</label>
      <label><input type="checkbox" id="optHaptics" checked> Haptics</label>
      <label>Sound Volume <input type="range" id="optVolume" min="0" max="1" step="0.05" value="0.6"><span id="volVal">0.60</span></label>
      <label>Snake Color
        <select id="optSnakeColor">
          <option value="#0f0" selected>Green</option>
          <option value="#00f">Blue</option>
          <option value="#f00">Red</option>
          <option value="#ff0">Yellow</option>
          <option value="#0ff">Cyan</option>
          <option value="#ff69b4">Pink</option>
          <option value="#ffa500">Orange</option>
        </select>
      </label>
      <label><input type="checkbox" id="optCB"> Color-blind palette</label>
    </fieldset>

    <fieldset>
      <legend>Rendering</legend>
      <label><input type="checkbox" id="optHiDPI" checked> High-DPI</label>
    </fieldset>

    <div class="row" style="margin-top:8px">
      <button id="btnSaveSettings">Save</button>
      <button id="btnBackMenu">Back</button>
    </div>
  </div>

  <!-- Modes Panel -->
  <div id="modesPanel" class="panel" aria-label="Modes">
    <h3>Modes</h3>
    <p>Choose a preset mode (you can still fine-tune in Settings):</p>
    <div class="row">
      <button class="btn" data-mode="classic">Classic</button>
      <button class="btn" data-mode="time">Time Trial</button>
      <button class="btn" data-mode="survival">Survival</button>
    </div>
    <div class="row" style="margin-top:8px"><button class="btn" data-action="back">Back</button></div>
  </div>

  <!-- Levels Panel -->
  <div id="levelsPanel" class="panel" aria-label="Levels">
    <h3>Levels</h3>
    <div class="lvlRow">
      <button class="btn" id="lvlPrev">◀</button>
      <div><div class="lvlName" id="lvlName">Level 1</div><div id="lvlInfo" style="font-size:.9rem; color:#9f9;">Speed 200 • Target 150</div></div>
      <button class="btn" id="lvlNext">▶</button>
    </div>
    <div class="row" style="margin-top:8px">
      <button class="btn" id="btnSelectLevel">Select & Back</button>
      <button class="btn" data-action="back">Back</button>
    </div>
  </div>

  <!-- Achievements Panel -->
  <div id="achPanel" class="panel" aria-label="Achievements">
    <h3>Achievements</h3>
    <ul id="achList" style="padding-left:18px; margin:0"></ul>
    <div class="row" style="margin-top:8px"><button class="btn" data-action="back">Back</button></div>
  </div>

  <!-- How To Panel -->
  <div id="howtoPanel" class="panel" aria-label="How to Play">
    <h3>How to Play</h3>
    <ul style="margin:0 0 6px 18px">
      <li>Use Arrow Keys or on-screen arrows to move. Space = Pause.</li>
      <li>Eat food to score points. Avoid walls and your own body.</li>
      <li>Power-ups: Shield (forgive 1 crash), SlowMo (time slows), Magnet (pulls nearby food).</li>
      <li>Portals (if enabled): enter one, exit at its pair.</li>
      <li>Time Trial: 60 seconds to score as high as possible.</li>
      <li>Survival: game gets faster over time.</li>
    </ul>
    <div class="row"><button class="btn" data-action="back">Back</button></div>
  </div>

  <div id="gameContainer">
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <div id="score">Score: 0</div>
    <div id="highScore">High Score: 0</div>
    <div id="lives">Lives: 3</div>
    <div id="timer">Time: 60</div>
  </div>

  <div id="controls" role="group" aria-label="Game controls">
    <button id="upBtn" class="control-btn" aria-label="Move Up">↑</button>
    <button id="leftBtn" class="control-btn" aria-label="Move Left">←</button>
    <button id="downBtn" class="control-btn" aria-label="Move Down">↓</button>
    <button id="rightBtn" class="control-btn" aria-label="Move Right">→</button>
  </div>

  <button id="pauseBtn" aria-label="Pause Game">Pause</button>

  <div id="gameOverModal" role="dialog" aria-modal="true" aria-labelledby="gameOverTitle">
    <div id="gameOverContent">
      <h2 id="gameOverTitle">Game Over!</h2>
      <p id="finalScore">Your Score: 0</p>
      <p id="finalHighScore">High Score: 0</p>
      <button id="restartBtn">Play Again</button>
      <div style="margin-top:6px"><button id="backToMenuBtn">Back to Menu</button></div>
    </div>
  </div>

<script>
(() => {
  // ======= STATE, SETTINGS, LEVELS =======
  const GameState = Object.freeze({ BOOT:'BOOT', MENU:'MENU', PLAYING:'PLAYING', PAUSED:'PAUSED', GAMEOVER:'GAMEOVER' });
  let gameState = GameState.BOOT;

  const SETTINGS_VERSION = 1;
  const DEFAULT_SETTINGS = {
    version: SETTINGS_VERSION,
    gameplay: {
      levelsWalls: true,
      portals: false,
      powerups: { enabled: true, shield: true, slow: true, magnet: true },
      enemySnake: false,
      livesSystem: true,
      timeTrial: false,
      survival: false,
      quests: false
    },
    controls: {
      inputBuffer: true,
      haptics: true,
      soundVolume: 0.6,
      snakeColor: '#0f0',
      colorBlindPalette: false
    },
    rendering: { hiDPI: true }
  };
  function loadSettings() {
    try {
      const raw = localStorage.getItem('snakeSettings2');
      if (!raw) return structuredClone(DEFAULT_SETTINGS);
      const parsed = JSON.parse(raw);
      if (!parsed.version || parsed.version < SETTINGS_VERSION) parsed.version = SETTINGS_VERSION;
      // merge shallow
      return { ...DEFAULT_SETTINGS, ...parsed,
        gameplay: { ...DEFAULT_SETTINGS.gameplay, ...parsed.gameplay,
          powerups: { ...DEFAULT_SETTINGS.gameplay.powerups, ...(parsed.gameplay?.powerups||{}) } },
        controls: { ...DEFAULT_SETTINGS.controls, ...parsed.controls },
        rendering: { ...DEFAULT_SETTINGS.rendering, ...parsed.rendering }
      };
    } catch { return structuredClone(DEFAULT_SETTINGS); }
  }
  function saveSettings(s){ localStorage.setItem('snakeSettings2', JSON.stringify(s)); }
  let SETTINGS = loadSettings();

  // Levels with ASCII walls and optional portals
  const levels = [
    {
      name:'Level 1', speed:200, targetScore:150,
      map:[
        "....................",
        "....................",
        "....................",
        "....................",
        "....######..........",
        "....................",
        "....................",
        "..........######....",
        "....................",
        "....................",
        "....................",
        "....######..........",
        "....................",
        "....................",
        "..........######....",
        "....................",
        "....................",
        "....................",
        "....................",
        "....................",
      ],
      portals: [ {a:{x:1,y:1}, b:{x:18,y:18}} ]
    },
    {
      name:'Level 2', speed:160, targetScore:220,
      map:[
        "#####...........####",
        "#####...........####",
        "....................",
        "....###########.....",
        "....................",
        ".....###########....",
        "....................",
        "....###########.....",
        "....................",
        "....................",
        "....................",
        ".....###########....",
        "....................",
        "....###########.....",
        "....................",
        "....................",
        "#####...........####",
        "#####...........####",
        "....................",
        "...................."
      ],
      portals: [ {a:{x:0,y:10}, b:{x:19,y:10}} ]
    }
  ];
  let currentLevelIndex = 0;

  // ======= DOM HOOKS =======
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const highScoreEl = document.getElementById('highScore');
  const livesEl = document.getElementById('lives');
  const timerEl = document.getElementById('timer');
  const pauseBtn = document.getElementById('pauseBtn');

  const mainMenu = document.getElementById('mainMenu');
  const settingsPanel = document.getElementById('settingsPanel');
  const modesPanel = document.getElementById('modesPanel');
  const levelsPanel = document.getElementById('levelsPanel');
  const achPanel = document.getElementById('achPanel');
  const howtoPanel = document.getElementById('howtoPanel');

  // Settings inputs
  const opt = {
    levelsWalls: document.getElementById('optLevelsWalls'),
    portals: document.getElementById('optPortals'),
    powerups: document.getElementById('optPowerups'),
    puShield: document.getElementById('optPUShield'),
    puSlow: document.getElementById('optPUSlow'),
    puMagnet: document.getElementById('optPUMagnet'),
    enemySnake: document.getElementById('optEnemySnake'),
    lives: document.getElementById('optLives'),
    timeTrial: document.getElementById('optTimeTrial'),
    survival: document.getElementById('optSurvival'),
    quests: document.getElementById('optQuests'),
    inputBuffer: document.getElementById('optInputBuffer'),
    haptics: document.getElementById('optHaptics'),
    volume: document.getElementById('optVolume'),
    volVal: document.getElementById('volVal'),
    snakeColor: document.getElementById('optSnakeColor'),
    cb: document.getElementById('optCB'),
    hiDPI: document.getElementById('optHiDPI'),
    btnSave: document.getElementById('btnSaveSettings'),
    btnBack: document.getElementById('btnBackMenu')
  };

  // Levels panel els
  const lvlName = document.getElementById('lvlName');
  const lvlInfo = document.getElementById('lvlInfo');
  const lvlPrev = document.getElementById('lvlPrev');
  const lvlNext = document.getElementById('lvlNext');
  const btnSelectLevel = document.getElementById('btnSelectLevel');

  const achList = document.getElementById('achList');

  // ======= GRID =======
  const cols = 20, rows = 20;
  let cellSize = canvas.width / cols;
  function applyHiDPI() {
    const dpr = (SETTINGS.rendering.hiDPI && window.devicePixelRatio) ? window.devicePixelRatio : 1;
    const cssW = 400, cssH = 400;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    cellSize = cssW / cols;
  }

  // ======= AUDIO =======
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function playTone(freq, duration=0.15, type='square') {
    if (SETTINGS.controls.soundVolume <= 0) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(SETTINGS.controls.soundVolume * 0.25, audioCtx.currentTime);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
  }
  function buzz(ms=30){ if(SETTINGS.controls.haptics) navigator.vibrate?.(ms); }

  // ======= GAME DATA =======
  let snake = [];
  let direction = {x:1,y:0};
  let nextDirection = {x:1,y:0};
  let inputQueue = []; // for input buffer
  let speed = 200;
  const minSpeed = 50, maxSpeed = 450;
  let score = 0, highScore = 0;
  let lives = 3;
  let foodItems = [];
  let walls = [];
  let portals = []; // [{a:{x,y}, b:{x,y}}]
  const maxFoodOnMap = 3;
  let lastTime = 0;
  let isPaused = false;
  let mode = 'classic'; // 'classic' | 'time' | 'survival'
  let timeLeft = 60; // for time trial
  let survivalRamp = 0; // accumulates to increase speed
  let runStartTs = 0;

  // Power-ups
  let powerUps = [];
  const powerUpTypes = {
    SHIELD: { name: 'Shield', color: '#00e5ff', ttlMs: 7000 },
    SLOW:   { name: 'SlowMo', color: '#7c4dff', ttlMs: 5000 },
    MAGNET: { name: 'Magnet', color: '#ffc400', ttlMs: 6000 }
  };
  let activeEffects = { shield:false, slowUntil:0, magnetUntil:0 };
  let powerUpSpawnTimer = 0, powerUpSpawnInterval = 8000;

  // Foods (color-blind palette optional)
  let baseFoodTypes = [
    {name:'Apple',  color:'#ff0000', points:10, grow:1, soundFreq:523.25},
    {name:'Banana', color:'#ffeb3b', points:20, grow:2, soundFreq:659.25},
    {name:'Cherry', color:'#d50000', points:30, grow:3, soundFreq:783.99},
    {name:'Poison', color:'#800080', points:-10,grow:-2, soundFreq:196.00}
  ];
  function getFoodTypes() {
    if (!SETTINGS.controls.colorBlindPalette) return baseFoodTypes;
    // Deuteranopia-friendly set
    return [
      {name:'Apple',  color:'#00bfff', points:10, grow:1, soundFreq:523.25},
      {name:'Banana', color:'#ffd500', points:20, grow:2, soundFreq:659.25},
      {name:'Cherry', color:'#ff7f7f', points:30, grow:3, soundFreq:783.99},
      {name:'Poison', color:'#8a2be2', points:-10,grow:-2, soundFreq:196.00}
    ];
  }

  // Achievements
  const ACH = [
    {id:'sc_200', title:'Score 200', test:()=>score>=200},
    {id:'no_poison_150', title:'150 without Poison', test:()=>score>=150 && !consumedPoisonThisRun},
    {id:'time_150', title:'Time Trial 150+', test:()=>mode==='time' && score>=150},
  ];
  let consumedPoisonThisRun = false;
  function loadAch(){ try{return JSON.parse(localStorage.getItem('snakeAch2')||'{}')}catch{return{}} }
  function saveAch(a){ localStorage.setItem('snakeAch2', JSON.stringify(a)); }
  let achState = loadAch();

  // ======= HELPERS =======
  function darkenColor(color, factor) {
    const r = Math.floor(parseInt(color.substr(1,2),16)*factor);
    const g = Math.floor(parseInt(color.substr(3,2),16)*factor);
    const b = Math.floor(parseInt(color.substr(5,2),16)*factor);
    return `rgb(${r},${g},${b})`;
  }
  function updateScoreUI(){ scoreEl.textContent = `Score: ${score}`; }
  function updateHighUI(){ highScoreEl.textContent = `High Score: ${highScore}`; }
  function updateLivesUI(){ livesEl.textContent = SETTINGS.gameplay.livesSystem ? `Lives: ${lives}` : 'Lives: ∞'; }
  function updateTimerUI(){ timerEl.textContent = (mode==='time') ? `Time: ${Math.max(0,Math.ceil(timeLeft))}` : (mode==='survival'?'Survival':'' ); }
  function loadHighScore(){
    const stored = localStorage.getItem('snakeHighScore2');
    if (stored){ highScore = parseInt(stored); updateHighUI(); }
  }
  function saveHighScore(){
    if (score > highScore) {
      highScore = score; localStorage.setItem('snakeHighScore2', highScore); updateHighUI();
    }
  }
  function vibrateSmall(){ buzz(18); }
  function vibrateHit(){ buzz(50); }

  function spawnFood() {
    const foodTypes = getFoodTypes();
    let tries=0;
    while(tries<500){
      const x = Math.floor(Math.random()*cols);
      const y = Math.floor(Math.random()*rows);
      if (snake.some(s=>s.x===x&&s.y===y)){tries++; continue;}
      if (foodItems.some(f=>f.x===x&&f.y===y)){tries++; continue;}
      if (walls.some(w=>w.x===x&&w.y===y)){tries++; continue;}
      if (powerUps.some(p=>p.x===x&&p.y===y)){tries++; continue;}
      return {x,y, ...foodTypes[Math.floor(Math.random()*foodTypes.length)]};
    }
    return {x:0,y:0,...foodTypes[0]};
  }
  function spawnFoodMultiple() { while(foodItems.length < maxFoodOnMap){ foodItems.push(spawnFood()); } }

  function spawnPowerUp() {
    if (!SETTINGS.gameplay.powerups.enabled) return;
    const candidates = [];
    if (SETTINGS.gameplay.powerups.shield) candidates.push(powerUpTypes.SHIELD);
    if (SETTINGS.gameplay.powerups.slow) candidates.push(powerUpTypes.SLOW);
    if (SETTINGS.gameplay.powerups.magnet) candidates.push(powerUpTypes.MAGNET);
    if (!candidates.length) return;
    const t = candidates[Math.floor(Math.random()*candidates.length)];
    let tries = 0;
    while(tries<500){
      const x = Math.floor(Math.random()*cols), y = Math.floor(Math.random()*rows);
      if (snake.some(s=>s.x===x&&s.y===y) || foodItems.some(f=>f.x===x&&f.y===y) || walls.some(w=>w.x===x&&w.y===y)) {tries++; continue;}
      powerUps.push({x,y,type:t, ttl:t.ttlMs}); break;
    }
  }

  function loadLevel(index){
    const L = levels[index];
    speed = L.speed;
    walls = [];
    for (let y=0; y<L.map.length; y++){
      for (let x=0; x<L.map[y].length; x++){
        if (L.map[y][x]==='#') walls.push({x,y});
      }
    }
    portals = (SETTINGS.gameplay.portals && L.portals) ? L.portals : [];
  }

  function resetSnake(){
    snake = [
      {x:8,y:10},{x:7,y:10},{x:6,y:10},{x:5,y:10}
    ];
    direction = {x:1,y:0};
    nextDirection = {x:1,y:0};
    inputQueue.length = 0;
  }

  function applyModePreset(m){
    mode = m;
    SETTINGS.gameplay.timeTrial = (m==='time');
    SETTINGS.gameplay.survival = (m==='survival');
    saveSettings(SETTINGS);
  }

  // ======= PANELS / MENU =======
  function showPanel(el){ [mainMenu,settingsPanel,modesPanel,levelsPanel,achPanel,howtoPanel].forEach(p=>p.classList.remove('visible')); el?.classList.add('visible'); }
  function openMenu(){ gameState = GameState.MENU; showPanel(mainMenu); }
  function openSettings(){
    // fill UI from SETTINGS
    opt.levelsWalls.checked = !!SETTINGS.gameplay.levelsWalls;
    opt.portals.checked = !!SETTINGS.gameplay.portals;
    opt.powerups.checked = !!SETTINGS.gameplay.powerups.enabled;
    opt.puShield.checked = !!SETTINGS.gameplay.powerups.shield;
    opt.puSlow.checked = !!SETTINGS.gameplay.powerups.slow;
    opt.puMagnet.checked = !!SETTINGS.gameplay.powerups.magnet;
    opt.enemySnake.checked = !!SETTINGS.gameplay.enemySnake;
    opt.lives.checked = !!SETTINGS.gameplay.livesSystem;
    opt.timeTrial.checked = !!SETTINGS.gameplay.timeTrial;
    opt.survival.checked = !!SETTINGS.gameplay.survival;
    opt.quests.checked = !!SETTINGS.gameplay.quests;
    opt.inputBuffer.checked = !!SETTINGS.controls.inputBuffer;
    opt.haptics.checked = !!SETTINGS.controls.haptics;
    opt.volume.value = SETTINGS.controls.soundVolume;
    opt.volVal.textContent = (+SETTINGS.controls.soundVolume).toFixed(2);
    opt.snakeColor.value = SETTINGS.controls.snakeColor;
    opt.cb.checked = !!SETTINGS.controls.colorBlindPalette;
    opt.hiDPI.checked = !!SETTINGS.rendering.hiDPI;
    showPanel(settingsPanel);
  }
  function saveSettingsFromUI(){
    SETTINGS.gameplay.levelsWalls = opt.levelsWalls.checked;
    SETTINGS.gameplay.portals = opt.portals.checked;
    SETTINGS.gameplay.powerups.enabled = opt.powerups.checked;
    SETTINGS.gameplay.powerups.shield = opt.puShield.checked;
    SETTINGS.gameplay.powerups.slow = opt.puSlow.checked;
    SETTINGS.gameplay.powerups.magnet = opt.puMagnet.checked;
    SETTINGS.gameplay.enemySnake = opt.enemySnake.checked;
    SETTINGS.gameplay.livesSystem = opt.lives.checked;
    SETTINGS.gameplay.timeTrial = opt.timeTrial.checked;
    SETTINGS.gameplay.survival = opt.survival.checked;
    // modes sync
    mode = SETTINGS.gameplay.timeTrial ? 'time' : (SETTINGS.gameplay.survival ? 'survival' : 'classic');
    SETTINGS.gameplay.quests = opt.quests.checked;

    SETTINGS.controls.inputBuffer = opt.inputBuffer.checked;
    SETTINGS.controls.haptics = opt.haptics.checked;
    SETTINGS.controls.soundVolume = parseFloat(opt.volume.value);
    SETTINGS.controls.snakeColor = opt.snakeColor.value;
    SETTINGS.controls.colorBlindPalette = opt.cb.checked;

    SETTINGS.rendering.hiDPI = opt.hiDPI.checked;

    saveSettings(SETTINGS);
    applyHiDPI();
  }

  document.querySelectorAll('#mainMenu .btn').forEach(b=>{
    b.addEventListener('click', e=>{
      const action = b.dataset.action;
      if (action==='play'){ startRun('classic'); }
      else if (action==='modes'){ showPanel(modesPanel); }
      else if (action==='levels'){ refreshLevelPanel(); showPanel(levelsPanel); }
      else if (action==='settings'){ openSettings(); }
      else if (action==='achievements'){ refreshAchievements(); showPanel(achPanel); }
      else if (action==='howto'){ showPanel(howtoPanel); }
    });
  });
  modesPanel.querySelectorAll('button[data-mode]').forEach(b=>{
    b.addEventListener('click', ()=>{
      const m = b.dataset.mode;
      applyModePreset(m);
      showPanel(mainMenu);
      startRun(m);
    });
  });
  modesPanel.querySelector('button[data-action="back"]').addEventListener('click', ()=> showPanel(mainMenu));
  achPanel.querySelector('button[data-action="back"]').addEventListener('click', ()=> showPanel(mainMenu));
  howtoPanel.querySelector('button[data-action="back"]').addEventListener('click', ()=> showPanel(mainMenu));

  opt.volume.addEventListener('input', ()=> opt.volVal.textContent = (+opt.volume.value).toFixed(2));
  opt.btnSave.addEventListener('click', ()=> { saveSettingsFromUI(); showPanel(mainMenu); });
  opt.btnBack.addEventListener('click', ()=> showPanel(mainMenu));

  // Levels panel logic
  function refreshLevelPanel(){
    const L = levels[currentLevelIndex];
    lvlName.textContent = L.name;
    lvlInfo.textContent = `Speed ${L.speed} • Target ${L.targetScore}`;
  }
  lvlPrev.addEventListener('click', ()=>{ currentLevelIndex = (currentLevelIndex-1+levels.length)%levels.length; refreshLevelPanel(); });
  lvlNext.addEventListener('click', ()=>{ currentLevelIndex = (currentLevelIndex+1)%levels.length; refreshLevelPanel(); });
  btnSelectLevel.addEventListener('click', ()=> { showPanel(mainMenu); });

  // Achievements list
  function refreshAchievements(){
    achList.innerHTML = '';
    ACH.forEach(a=>{
      const li = document.createElement('li');
      const unlocked = !!achState[a.id];
      li.textContent = (unlocked?'✅ ':'⬜ ') + a.title;
      achList.appendChild(li);
    });
  }
  function checkAchievements(){
    let changed=false;
    ACH.forEach(a=>{
      if (!achState[a.id] && a.test()){
        achState[a.id] = {date: Date.now()};
        changed = true;
      }
    });
    if (changed) saveAch(achState);
  }

  // ======= GAME FLOW =======
  function startRun(presetMode='classic'){
    // apply preset (but keep user custom toggles already saved)
    mode = presetMode || mode;
    showPanel(null); // hide all
    gameState = GameState.PLAYING;
    isPaused = false;
    consumedPoisonThisRun = false;
    survivalRamp = 0;
    runStartTs = performance.now();

    // init
    loadHighScore();
    applyHiDPI();
    loadLevel(currentLevelIndex);
    resetSnake();
    score = 0;
    foodItems = [];
    powerUps = [];
    spawnFoodMultiple();
    if (SETTINGS.gameplay.livesSystem) lives = 3; else lives = Infinity;
    timeLeft = 60;

    updateScoreUI(); updateHighUI(); updateLivesUI(); updateTimerUI();
    lastTime = 0;
    window.requestAnimationFrame(gameLoop);
  }

  function togglePause(){
    if (gameState!==GameState.PLAYING && gameState!==GameState.PAUSED) return;
    isPaused = !isPaused;
    gameState = isPaused ? GameState.PAUSED : GameState.PLAYING;
    pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
    if (!isPaused) window.requestAnimationFrame(gameLoop);
  }
  pauseBtn.addEventListener('click', togglePause);

  // ======= INPUT =======
  function enqueueDirection(nx,ny){
    // prevent 180° reversal; consider current or queued last
    const last = inputQueue.length? inputQueue[inputQueue.length-1] : direction;
    if (last.x === -nx && last.y === -ny) return;
    inputQueue.push({x:nx,y:ny});
    if (!SETTINGS.controls.inputBuffer){
      // keep only 1 next
      inputQueue = [inputQueue[0]];
    } else if (inputQueue.length>2){
      inputQueue = inputQueue.slice(-2);
    }
  }
  window.addEventListener('keydown', e=>{
    if (gameState===GameState.MENU){ if (e.key==='Enter') startRun('classic'); return; }
    if (e.key===' ') { togglePause(); return; }
    if (isPaused) return;
    if (e.key==='ArrowUp' && direction.y===0) enqueueDirection(0,-1);
    else if (e.key==='ArrowDown' && direction.y===0) enqueueDirection(0,1);
    else if (e.key==='ArrowLeft' && direction.x===0) enqueueDirection(-1,0);
    else if (e.key==='ArrowRight' && direction.x===0) enqueueDirection(1,0);
  });

  // touch swipe
  let touchStartX=null, touchStartY=null; const swipeThreshold=30;
  canvas.addEventListener('touchstart', e=>{
    if(e.touches.length===1){ touchStartX=e.touches[0].clientX; touchStartY=e.touches[0].clientY; }
  });
  canvas.addEventListener('touchmove', e=>{
    if(!touchStartX||!touchStartY||isPaused) return;
    let dx = e.touches[0].clientX - touchStartX;
    let dy = e.touches[0].clientY - touchStartY;
    if(Math.abs(dx)>Math.abs(dy)){
      if(dx>swipeThreshold && direction.x===0) enqueueDirection(1,0);
      else if(dx<-swipeThreshold && direction.x===0) enqueueDirection(-1,0);
    } else {
      if(dy>swipeThreshold && direction.y===0) enqueueDirection(0,1);
      else if(dy<-swipeThreshold && direction.y===0) enqueueDirection(0,-1);
    }
    touchStartX=null; touchStartY=null;
  });

  // onscreen controls
  document.getElementById('upBtn').addEventListener('click', ()=>{ if(!isPaused && direction.y===0) enqueueDirection(0,-1); });
  document.getElementById('downBtn').addEventListener('click', ()=>{ if(!isPaused && direction.y===0) enqueueDirection(0,1); });
  document.getElementById('leftBtn').addEventListener('click', ()=>{ if(!isPaused && direction.x===0) enqueueDirection(-1,0); });
  document.getElementById('rightBtn').addEventListener('click', ()=>{ if(!isPaused && direction.x===0) enqueueDirection(1,0); });

  // ======= GAME LOOP =======
  function effectiveSpeed(ts){
    let s = speed;
    if (activeEffects.slowUntil > ts) s = Math.min(s * 1.8, maxSpeed);
    if (mode==='survival'){
      const elapsed = (ts - runStartTs) / 1000;
      s = Math.max(120 - Math.min(elapsed*2.2, 70), 70); // faster over time
    }
    return s;
  }

  function gameLoop(timestamp){
    if (gameState!==GameState.PLAYING) return;
    if(!lastTime) lastTime = timestamp;
    if(isPaused){ lastTime = timestamp; window.requestAnimationFrame(gameLoop); return; }

    // spawn powerups
    if (!powerUpSpawnTimer) powerUpSpawnTimer = timestamp;
    if (timestamp - powerUpSpawnTimer > powerUpSpawnInterval && powerUps.length<2){
      spawnPowerUp(); powerUpSpawnTimer = timestamp;
    }

    // Time Trial countdown
    if (mode==='time'){
      if (timestamp - lastTime >= 16){
        timeLeft -= (timestamp - lastTime)/1000;
        if (timeLeft <= 0){ endGame(); return; }
        updateTimerUI();
      }
    } else {
      timerEl.textContent = (mode==='survival')?'Survival':'';
    }

    const eSpeed = effectiveSpeed(timestamp);
    const elapsed = timestamp - lastTime;
    if (elapsed > eSpeed){
      update(timestamp);
      draw(timestamp);
      lastTime = timestamp;
    }
    window.requestAnimationFrame(gameLoop);
  }

  // ======= UPDATE =======
  function takeFromQueue(){
    if (inputQueue.length){
      const n = inputQueue.shift();
      // guard against instant reverse current direction
      if (!(direction.x === -n.x && direction.y === -n.y)) nextDirection = n;
    }
  }

  function usePortal(head){
    if (!SETTINGS.gameplay.portals || !portals.length) return head;
    for (const p of portals){
      if (head.x===p.a.x && head.y===p.a.y) return {x:p.b.x, y:p.b.y};
      if (head.x===p.b.x && head.y===p.b.y) return {x:p.a.x, y:p.a.y};
    }
    return head;
  }

  function endLifeOrGame(){
    if (SETTINGS.gameplay.livesSystem){
      lives = (lives===Infinity)? Infinity : Math.max(0,lives-1);
      updateLivesUI();
      if (lives<=0){ endGame(); }
      else {
        vibrateHit(); playTone(120,0.2,'sawtooth');
        resetSnake();
      }
    } else { endGame(); }
  }

  function update(nowTs){
    // apply queued input
    takeFromQueue();
    direction = nextDirection;
    let head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

    // Portals pre-wall? We check bounds first, then portal wrap
    const out = (head.x<0 || head.x>=cols || head.y<0 || head.y>=rows);
    if (out || walls.some(w=>w.x===head.x && w.y===head.y) || snake.some(seg=>seg.x===head.x && seg.y===head.y)){
      if (activeEffects.shield){ activeEffects.shield=false; vibrateHit(); playTone(260,0.08); return; }
      // If exactly stepping on portal outside bounds, ignore. Otherwise life--
      if (!SETTINGS.gameplay.portals || !portals.length) { endLifeOrGame(); return; }
      // try allow portal usage even if hitting a portal cell
      // (handled below after move)
    }

    head = usePortal(head);

    snake.unshift(head);

    // Magnet pulls
    if (activeEffects.magnetUntil > nowTs){
      const pullDist = 2;
      foodItems.forEach(f=>{
        const dist = Math.abs(f.x - head.x) + Math.abs(f.y - head.y);
        if (dist<=pullDist){
          if (f.x<head.x) f.x++; else if (f.x>head.x) f.x--;
          if (f.y<head.y) f.y++; else if (f.y>head.y) f.y--;
        }
      });
    }

    // Eat food
    let ateFoodIndex = -1;
    for (let i=0;i<foodItems.length;i++){
      const f = foodItems[i];
      if (f.x===head.x && f.y===head.y){ ateFoodIndex=i; break; }
    }
    if (ateFoodIndex !== -1){
      const eaten = foodItems[ateFoodIndex];
      playTone(eaten.soundFreq);
      vibrateSmall();

      score += eaten.points;
      if (eaten.points<0) consumedPoisonThisRun = true;
      if (score<0) score=0;

      if (eaten.grow>0){
        for (let i=0;i<eaten.grow-1;i++) snake.push({...snake[snake.length-1]});
      } else if (eaten.grow<0){
        snake.splice(eaten.grow);
        if (snake.length<3){ endLifeOrGame(); return; }
      }

      updateScoreUI(); saveHighScore(); checkAchievements();

      foodItems.splice(ateFoodIndex,1);
      foodItems.push(spawnFood());
    } else {
      snake.pop();
    }

    // Collect power-up
    let got = -1;
    for (let i=0;i<powerUps.length;i++){ const p=powerUps[i]; if (p.x===head.x && p.y===head.y){ got=i; break; } }
    if (got!==-1){
      const p = powerUps[got];
      if (p.type===powerUpTypes.SHIELD) activeEffects.shield = true;
      else if (p.type===powerUpTypes.SLOW) activeEffects.slowUntil = nowTs + p.type.ttlMs;
      else if (p.type===powerUpTypes.MAGNET) activeEffects.magnetUntil = nowTs + p.type.ttlMs;
      playTone(880,0.12); vibrateSmall();
      powerUps.splice(got,1);
    }

    // Decay power-ups on board
    powerUps = powerUps.filter(p=> (p.ttl -= speed) > 0);
  }

  // ======= DRAW =======
  function draw(ts){
    // BG tint for active effects
    if (activeEffects.slowUntil > performance.now()){ ctx.fillStyle = '#001a1a'; }
    else if (activeEffects.magnetUntil > performance.now()){ ctx.fillStyle = '#1a1a00'; }
    else { ctx.fillStyle='#000'; }
    ctx.fillRect(0,0,400,400);

    // Walls
    if (SETTINGS.gameplay.levelsWalls){
      walls.forEach(w=>{
        ctx.fillStyle='#333';
        ctx.fillRect(w.x*cellSize, w.y*cellSize, cellSize, cellSize);
        ctx.strokeStyle='#0f0'; ctx.lineWidth=1;
        ctx.strokeRect(w.x*cellSize, w.y*cellSize, cellSize, cellSize);
      });
    }

    // Portals
    if (SETTINGS.gameplay.portals){
      portals.forEach(p=>{
        const r = cellSize*0.35;
        ctx.strokeStyle='#00ffff'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(p.a.x*cellSize+cellSize/2, p.a.y*cellSize+cellSize/2, r, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(p.b.x*cellSize+cellSize/2, p.b.y*cellSize+cellSize/2, r, 0, Math.PI*2); ctx.stroke();
      });
    }

    // Foods
    foodItems.forEach(f=>{
      const padding = cellSize*0.15;
      const radius = cellSize/2 - padding;
      ctx.fillStyle = f.color;
      ctx.beginPath();
      ctx.ellipse(f.x*cellSize+cellSize/2, f.y*cellSize+cellSize/2, radius, radius, 0, 0, Math.PI*2);
      ctx.fill();
    });

    // Power-ups
    if (SETTINGS.gameplay.powerups.enabled){
      powerUps.forEach(p=>{
        const padding = cellSize*0.2;
        ctx.fillStyle = p.type.color;
        ctx.fillRect(p.x*cellSize+padding, p.y*cellSize+padding, cellSize-2*padding, cellSize-2*padding);
      });
    }

    // Snake
    const snakeColor = SETTINGS.controls.snakeColor;
    const snakeBorderColor = darkenColor(snakeColor,0.7);
    snake.forEach((seg,i)=>{
      ctx.fillStyle = (i===0)? snakeColor : snakeBorderColor;
      ctx.fillRect(seg.x*cellSize, seg.y*cellSize, cellSize, cellSize);
      ctx.strokeStyle = snakeBorderColor; ctx.lineWidth=1;
      ctx.strokeRect(seg.x*cellSize, seg.y*cellSize, cellSize, cellSize);
    });

    // UI
    updateTimerUI();
  }

  // ======= END GAME / MODAL =======
  function endGame(){
    gameState = GameState.GAMEOVER;
    isPaused = true;
    saveHighScore();
    document.getElementById('finalScore').textContent = `Your Score: ${score}`;
    document.getElementById('finalHighScore').textContent = `High Score: ${highScore}`;
    document.getElementById('gameOverModal').classList.add('visible');
  }
  function hideGameOver(){ document.getElementById('gameOverModal').classList.remove('visible'); }

  document.getElementById('restartBtn').addEventListener('click', ()=>{ hideGameOver(); startRun(mode); });
  document.getElementById('backToMenuBtn').addEventListener('click', ()=>{ hideGameOver(); openMenu(); });

  // ======= BOOT =======
  openMenu(); // start at menu
})();
</script>
</body>
</html>
